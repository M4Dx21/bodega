# -*- coding: utf-8 -*-python datos.py

"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ktGYyhQHVqiYf34l5sayuqCcx4JMzvU9
"""


import pandas as pd
from sklearn.linear_model import LinearRegression
import plotly.express as px
import plotly.figure_factory as ff

# Cargar datos
cirugias = pd.read_csv('cirugias.csv')
componentes = pd.read_csv('componentes.csv')

import json

# Leer los filtros desde filtros.json
with open('filtros.json') as f:
    filtros = json.load(f)

filtro_especialidad = filtros.get('especialidad', '').lower()
fecha_inicio = filtros.get('fecha_inicio')
fecha_fin = filtros.get('fecha_fin')

# Filtrar por fecha si se indicó
if fecha_inicio and fecha_fin:
    cirugias['fecha_sol'] = pd.to_datetime(cirugias['fecha_sol'], errors='coerce')
    mask = (cirugias['fecha_sol'] >= fecha_inicio) & (cirugias['fecha_sol'] <= fecha_fin)
    cirugias = cirugias[mask]

# Filtrar por especialidad si se indicó
if filtro_especialidad:
    componentes = componentes[componentes['especialidad'].str.lower() == filtro_especialidad]

# Expandir insumos (ej: "GUANTE (x2), BISTURI (x1)")
def expandir_insumos(row):
    resultado = []
    insumos = str(row['insumos']).split(',')
    for ins in insumos:
        ins = ins.strip()
        if '(x' in ins:
            nombre, cantidad = ins.split('(x')
            cantidad = int(cantidad.replace(')', '').strip())
        else:
            nombre = ins
            cantidad = 1
        resultado.append({
            'insumo': nombre.strip(),
            'cantidad': cantidad,
            'fecha_sol': row['fecha_sol']
        })
    return resultado

# Aplicar expansión
datos_expand = []
for _, fila in cirugias.iterrows():
    datos_expand.extend(expandir_insumos(fila))

df_insumos = pd.DataFrame(datos_expand)
# Asegurarse de que fecha_sol esté como datetime
df_insumos['fecha_sol'] = pd.to_datetime(df_insumos['fecha_sol'], errors='coerce')
df_insumos['mes'] = df_insumos['fecha_sol'].dt.to_period('M')

# Cargar solo columnas relevantes de componentes
componentes = componentes[['insumo', 'especialidad', 'stock']]

# 🔄 Hacemos el merge con left siempre (para no perder insumos si no hay filtro)
df_merged = df_insumos.merge(componentes, on='insumo', how='left')

# Si hay filtro de especialidad, aplicarlo luego del merge
if filtro_especialidad:
    df_merged = df_merged[df_merged['especialidad'].str.lower() == filtro_especialidad]

# 🐞 Info útil para depurar
print("Filtros aplicados:")
print(f"  Especialidad: {filtro_especialidad if filtro_especialidad else 'Ninguna'}")
print(f"  Fecha inicio: {fecha_inicio if fecha_inicio else 'No definida'}")
print(f"  Fecha fin: {fecha_fin if fecha_fin else 'No definida'}")
print(f"Total filas luego de merge y filtros: {len(df_merged)}")


# Agrupar por mes e insumo
df_grouped = df_merged.groupby(['mes', 'insumo'])['cantidad'].sum().reset_index()

# DASHBOARD 1: Predicción de insumos necesarios a fin de mes
conteo_insumos = df_grouped['insumo'].value_counts()
insumos_validos = conteo_insumos[conteo_insumos >= 3].index

resultados = []
for insumo in insumos_validos:
    datos = df_grouped[df_grouped['insumo'] == insumo].copy()
    datos = datos.sort_values('mes')
    datos['mes_num'] = range(len(datos))

    X = datos[['mes_num']]
    y = datos['cantidad']
    modelo = LinearRegression().fit(X, y)

    futuro = pd.DataFrame({'mes_num': range(len(X), len(X) + 1)})
    futuro['prediccion'] = modelo.predict(futuro[['mes_num']])
    futuro['insumo'] = insumo

    resultados.append(futuro)

df_pred = pd.concat(resultados)
df_pred['prediccion'] = df_pred['prediccion'].round().astype(int)
df_pred.sort_values('prediccion', ascending=True, inplace=True)

fig1 = px.bar(df_pred, x='prediccion', y='insumo', orientation='h',
              title='Predicción de insumos necesarios a fin de mes',
              labels={'prediccion': 'Cantidad estimada', 'insumo': 'Insumo'})
fig1.update_layout(height=600)
fig1.write_html("graficos/dashboard1_prediccion.html")
fig1.show()

# DASHBOARD 2: Top 10 productos más consumidos
mensual = df_grouped.groupby('insumo')['cantidad'].sum().sort_values(ascending=False).head(10)
mensual = mensual.rename_axis('insumo').reset_index(name='cantidad')

fig2 = px.bar(mensual, x='cantidad', y='insumo', orientation='h',
              title='10 productos más consumidos',
              labels={'cantidad': 'Cantidad total', 'insumo': 'Insumo'})
fig2.update_layout(height=500)
fig2.write_html("graficos/dashboard2_top10.html")
fig2.show()

# DASHBOARD 3: Insumo más consumido por especialidad
import plotly.express as px
especialidad_group = df_merged.groupby(['especialidad', 'insumo'])['cantidad'].sum().reset_index()
especialidad_top = especialidad_group.sort_values(['especialidad', 'cantidad'], ascending=[True, False])
top_insumos = especialidad_top.groupby('especialidad').first().reset_index()

# Pie chart con insumo más consumido por especialidad
fig3 = px.pie(top_insumos, 
              names='especialidad', 
              values='cantidad', 
              title='Insumo más consumido por especialidad',
              hole=0.3)  # Si quieres un estilo donut, si no, elimínalo

# Guardar el HTML
fig3.write_html("graficos/dashboard3_especialidades_pie.html")


# DASHBOARD 4: Mapa de calor mensual
heatmap_data = df_grouped.pivot_table(index='insumo', columns='mes', values='cantidad', aggfunc='sum', fill_value=0)
z = heatmap_data.values
x = heatmap_data.columns.astype(str)
y = heatmap_data.index

fig4 = ff.create_annotated_heatmap(z, x=list(x), y=list(y), colorscale='YlGnBu', showscale=True)
fig4.update_layout(title='Mapa de calor: consumo mensual por insumo', height=800)
fig4.write_html("graficos/dashboard4_heatmap.html")
fig4.show()
